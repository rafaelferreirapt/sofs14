<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SOFS14: sofs_buffercache.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SOFS14
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">FUSE based file system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sofs__buffercache_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sofs_buffercache.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Access to buffered/unbuffered raw disk blocks and clusters.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br/>
</div>
<p><a href="sofs__buffercache_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a24f52ac52d6e714cb04a5aa01be3bdd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24f52ac52d6e714cb04a5aa01be3bdd0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercache_8h.html#a24f52ac52d6e714cb04a5aa01be3bdd0">BUF</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a24f52ac52d6e714cb04a5aa01be3bdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">the communication channel to the storage device is buffered <br/></td></tr>
<tr class="separator:a24f52ac52d6e714cb04a5aa01be3bdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae908fc13b6fb17824d400c74a6430f84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae908fc13b6fb17824d400c74a6430f84"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercache_8h.html#ae908fc13b6fb17824d400c74a6430f84">UNBUF</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ae908fc13b6fb17824d400c74a6430f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">the communication channel to the storage device is unbuffered <br/></td></tr>
<tr class="separator:ae908fc13b6fb17824d400c74a6430f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5605dce2536755fb4a0e3f553dce38f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercache_8h.html#a5605dce2536755fb4a0e3f553dce38f1">soOpenBufferCache</a> (const char *devname, uint32_t type)</td></tr>
<tr class="memdesc:a5605dce2536755fb4a0e3f553dce38f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the storage area and assign it to the storage device.  <a href="#a5605dce2536755fb4a0e3f553dce38f1">More...</a><br/></td></tr>
<tr class="separator:a5605dce2536755fb4a0e3f553dce38f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabc7ed309f4bf56103e2b0ccc4e2443"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercache_8h.html#aaabc7ed309f4bf56103e2b0ccc4e2443">soCloseBufferCache</a> (void)</td></tr>
<tr class="memdesc:aaabc7ed309f4bf56103e2b0ccc4e2443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unassign the storage area from the storage device and perform the required housekeeping duties.  <a href="#aaabc7ed309f4bf56103e2b0ccc4e2443">More...</a><br/></td></tr>
<tr class="separator:aaabc7ed309f4bf56103e2b0ccc4e2443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d6f88ec69eb85d9b74d4906f1e001e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercache_8h.html#ae9d6f88ec69eb85d9b74d4906f1e001e">soReadCacheBlock</a> (uint32_t n, void *buf)</td></tr>
<tr class="memdesc:ae9d6f88ec69eb85d9b74d4906f1e001e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a block of data from the buffercache.  <a href="#ae9d6f88ec69eb85d9b74d4906f1e001e">More...</a><br/></td></tr>
<tr class="separator:ae9d6f88ec69eb85d9b74d4906f1e001e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359dab16dae75cf33de800c39af68c86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercache_8h.html#a359dab16dae75cf33de800c39af68c86">soWriteCacheBlock</a> (uint32_t n, void *buf)</td></tr>
<tr class="memdesc:a359dab16dae75cf33de800c39af68c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a block of data to the buffercache.  <a href="#a359dab16dae75cf33de800c39af68c86">More...</a><br/></td></tr>
<tr class="separator:a359dab16dae75cf33de800c39af68c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d8aa2c229445c987b4f025cdb43068"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercache_8h.html#af1d8aa2c229445c987b4f025cdb43068">soFlushCacheBlock</a> (uint32_t n, void *buf)</td></tr>
<tr class="memdesc:af1d8aa2c229445c987b4f025cdb43068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush a block of data to the storage device.  <a href="#af1d8aa2c229445c987b4f025cdb43068">More...</a><br/></td></tr>
<tr class="separator:af1d8aa2c229445c987b4f025cdb43068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafde851449dab69295d126ae820b454e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercache_8h.html#aafde851449dab69295d126ae820b454e">soSyncCacheBlock</a> (uint32_t n)</td></tr>
<tr class="memdesc:aafde851449dab69295d126ae820b454e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize a block of data with the same block in the storage device.  <a href="#aafde851449dab69295d126ae820b454e">More...</a><br/></td></tr>
<tr class="separator:aafde851449dab69295d126ae820b454e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57e8a0d5bed7838ce0ab9a4ced20d48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercache_8h.html#ac57e8a0d5bed7838ce0ab9a4ced20d48">soReadCacheCluster</a> (uint32_t n, void *buf)</td></tr>
<tr class="memdesc:ac57e8a0d5bed7838ce0ab9a4ced20d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a cluster of data from the buffercache.  <a href="#ac57e8a0d5bed7838ce0ab9a4ced20d48">More...</a><br/></td></tr>
<tr class="separator:ac57e8a0d5bed7838ce0ab9a4ced20d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e17854cdabaf218b81aaf6cf79e4c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercache_8h.html#a25e17854cdabaf218b81aaf6cf79e4c8">soWriteCacheCluster</a> (uint32_t n, void *buf)</td></tr>
<tr class="memdesc:a25e17854cdabaf218b81aaf6cf79e4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a cluster of data to the buffercache.  <a href="#a25e17854cdabaf218b81aaf6cf79e4c8">More...</a><br/></td></tr>
<tr class="separator:a25e17854cdabaf218b81aaf6cf79e4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd37ad77afc838c333601eab6ca5703"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercache_8h.html#afdd37ad77afc838c333601eab6ca5703">soFlushCacheCluster</a> (uint32_t n, void *buf)</td></tr>
<tr class="memdesc:afdd37ad77afc838c333601eab6ca5703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush a cluster of data to the storage device.  <a href="#afdd37ad77afc838c333601eab6ca5703">More...</a><br/></td></tr>
<tr class="separator:afdd37ad77afc838c333601eab6ca5703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c460cae9d802042424b9d32adfeaa4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__buffercache_8h.html#a95c460cae9d802042424b9d32adfeaa4">soSyncCacheCluster</a> (uint32_t n)</td></tr>
<tr class="memdesc:a95c460cae9d802042424b9d32adfeaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize a cluster of data with the same cluster in the storage device.  <a href="#a95c460cae9d802042424b9d32adfeaa4">More...</a><br/></td></tr>
<tr class="separator:a95c460cae9d802042424b9d32adfeaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Access to buffered/unbuffered raw disk blocks and clusters. </p>
<p>(interface file)</p>
<p>The mean transfer time of a data block (cluster) between main memory and disk is typically at least tens of thousands of times longer than the transfer time of an equal data block (cluster) between two different locations in main memory. Thus, the operating system tries to keep in a private storage area copies of the data blocks (clusters) whose probability of access in the near future is higher.</p>
<p>The buffercache may be regarded as a storage area resident in main memory having the ability to store K data blocks of the device's storage space. Data transfer between the main memory and the device works according to the following rules: </p>
<ul>
<li>every time a data block (cluster) is required for reading, it is looked up in the storage area: if it is there, the contents is copied to the supplied buffer location; otherwise, it is first read from the device and stored in the buffercache (a new node in the storage area is initialized to it and its status is marked <em>same</em>), then its contents is copied to the supplied buffer location, as before </li>
<li>every time a data block (cluster) is required for writing, it is looked up in the storage area: if it is there, the contents of the supplied buffer is copied into it and its status is marked <em>changed</em>; otherwise, a new node in the storage area is initialized to this data block (cluster), the contents of the supplied buffer is copied into it and its status is marked <em>changed</em>, as before </li>
<li>because the number of nodes in the storage area is finite, whenever it happens that no more free nodes are available, the node that has not been accessed for the longest time is selected for replacement: its contents, if needed (the status is marked <em>changed</em>), is first transfered to the device, then it becomes available for a new assignment.</li>
</ul>
<p>The following operations are defined: </p>
<ul>
<li>initialize the storage area and assign it to the storage device </li>
<li>unassign the storage area from the storage device and perform the required housekeeping duties </li>
<li>read a block of data from the buffercache </li>
<li>write a block of data to the buffercache </li>
<li>flush a block of data to the storage device </li>
<li>synchronize a block of data with the same block in the storage device </li>
<li>read a cluster of data from the buffercache </li>
<li>write a cluster of data to the buffercache </li>
<li>flush a cluster of data to the storage device </li>
<li>synchronize a cluster of data with the same cluster in the storage device.</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Artur Carneiro Pereira - September 2007 </dd>
<dd>
Miguel Oliveira e Silva - September 2009 </dd>
<dd>
Ant√≥nio Rui Borges - July 2010 / August 2011</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In case an error occurs, all functions return a negative value which is the symmetric of the system error that better represents the error cause. (execute command <em>man errno</em> to get the list of system errors) </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aaabc7ed309f4bf56103e2b0ccc4e2443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soCloseBufferCache </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unassign the storage area from the storage device and perform the required housekeeping duties. </p>
<p>The buffered/unbuffered communication channel previously established with the storage device is closed. This means, namely, that the contents of the storage area is flushed into the storage device to keep data consistent.</p>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<code>ELIBBAD</code>, if the internal data is inconsistent </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="af1d8aa2c229445c987b4f025cdb43068"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soFlushCacheBlock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush a block of data to the storage device. </p>
<p>Both the physical number of the data block to be written and a pointer to a previously allocated buffer are supplied as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>physical number of the block to be flushed </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to the buffer containing the data to be written from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if <em>buffer pointer</em> is <code>NULL</code> or <em>block number</em> is out of range </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<code>ELIBBAD</code>, if the buffercache is inconsistent </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="afdd37ad77afc838c333601eab6ca5703"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soFlushCacheCluster </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush a cluster of data to the storage device. </p>
<p>The device is organized as a linear array of data blocks. A cluster is a group of successive blocks. Both the physical number of the first block of the data cluster to be flushed and a pointer to a previously allocated buffer are supplied as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>physical number of the first block of the data cluster to be flushed </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to the buffer containing the data to be written from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if <em>buffer pointer</em> is <code>NULL</code> or <em>block number</em> is out of range </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<code>ELIBBAD</code>, if the buffercache is inconsistent </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a5605dce2536755fb4a0e3f553dce38f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soOpenBufferCache </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>devname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the storage area and assign it to the storage device. </p>
<p>A communication channel is established with the storage device so that data transfers between main memory and the storage device may be minimized. This communication may be unbuffered or buffered: it will be unbuffered, if the second argument is <code>UNBUF</code> , and buffered, in any other case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devname</td><td>absolute path to the Linux file that simulates the storage device </td></tr>
    <tr><td class="paramname">type</td><td>type of the communication channel that is opened</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the argument is <code>NULL</code> </dd>
<dd>
-<code>EBUSY</code>, if the storage area is already in use or the device is already opened </dd>
<dd>
-<code>ELIBBAD</code>, if the supporting file size is invalid </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ae9d6f88ec69eb85d9b74d4906f1e001e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soReadCacheBlock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a block of data from the buffercache. </p>
<p>Both the physical number of the data block to be read and a pointer to a previously allocated buffer are supplied as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>physical number of the data block to be read from </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to the buffer where the data must be read into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>buffer pointer</em> is <code>NULL</code> or the <em>block number</em> is out of range </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on reading or writing </dd>
<dd>
-<code>ELIBBAD</code>, if the buffercache is inconsistent </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ac57e8a0d5bed7838ce0ab9a4ced20d48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soReadCacheCluster </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a cluster of data from the buffercache. </p>
<p>The device is organized as a linear array of data blocks. A cluster is a group of successive blocks. Both the physical number of the first block of the data cluster to be read and a pointer to a previously allocated buffer are supplied as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>physical number of the first block of the data cluster to be read from </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to the buffer where the data must be read into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>buffer pointer</em> is <code>NULL</code> or the <em>block number</em> is out of range </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on reading or writing </dd>
<dd>
-<code>ELIBBAD</code>, if the buffercache is inconsistent </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="aafde851449dab69295d126ae820b454e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soSyncCacheBlock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize a block of data with the same block in the storage device. </p>
<p>The physical number of the data block to be synchronized is supplied as argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>physical number of the block to be synchronized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if <em>block number</em> is out of range </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<code>ELIBBAD</code>, if the buffercache is inconsistent </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a95c460cae9d802042424b9d32adfeaa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soSyncCacheCluster </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize a cluster of data with the same cluster in the storage device. </p>
<p>The device is organized as a linear array of data blocks. A cluster is a group of successive blocks. The physical number of the data cluster to be synchronized is supplied as argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>physical number of the first block of the data cluster to be synchronized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if <em>block number</em> is out of range </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<code>ELIBBAD</code>, if the buffercache is inconsistent </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a359dab16dae75cf33de800c39af68c86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soWriteCacheBlock </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a block of data to the buffercache. </p>
<p>Both the physical number of the data block to be written and a pointer to a previously allocated buffer are supplied as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>physical number of the block to be written into </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to the buffer containing the data to be written from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if <em>buffer pointer</em> is <code>NULL</code> or <em>block number</em> is out of range </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<code>ELIBBAD</code>, if the buffercache is inconsistent </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a25e17854cdabaf218b81aaf6cf79e4c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soWriteCacheCluster </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a cluster of data to the buffercache. </p>
<p>The device is organized as a linear array of data blocks. A cluster is a group of successive blocks. Both the physical number of the first block of the data cluster to be written and a pointer to a previously allocated buffer are supplied as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>physical number of the first block of the data cluster to be written into </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to the buffer containing the data to be written from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if <em>buffer pointer</em> is <code>NULL</code> or <em>block number</em> is out of range </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<code>ELIBBAD</code>, if the buffercache is inconsistent </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b51697affdfb890613a0fe9bc67aa3d1.html">rawIO14</a></li><li class="navelem"><a class="el" href="sofs__buffercache_8h.html">sofs_buffercache.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
